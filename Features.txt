### INFO

VHDL 1993
Using the Cyclone II DE 2: EP2C35F672C6N 
	It has 105 M4K blocks.
	Each M4K block has 4,608 bits.
	It can be configured as 4,096 x 1-bit, 2,048 x 2-bit, 1,024 x 4-bit, 512 x 9-bit, and so on.
	It supports true dual-port, simple dual-port, and single-port RAM configurations.




### FEATURES
[ppu]
	custom shift functions
	basic ALU structure

[memory_controller]

	basic memory implementation to utilize dual-port RAM, which allows simultaneous read/write 
	operations on two different addresses. This can be extremely useful in a GPU setting where 
	one part of the system might be writing data (e.g., the PPU) while another part reads data 
	(e.g., the VGA controller).
	
	write protection
	
	write and read activity indicators

	
[ppu_controller]
	The ppu_controller is the heart of your GPU. It will manage the distribution of tasks to the 
	Pixel Processing Units (PPUs), collect results after computation, and might also manage the
	flow of data between the memory and the PPUs.
	
	{writing to both RAMs at the same time (we can then read two different values at a time)}
	
	with it having one ALU it used to take 
	112690 ns
	to both load the ram then start reading the arrays and add them. now, by adding two elements at a time in parallel it takes
	76830 ns
	thats a 31.81 % improvement
	
### IMPROVEMENTS: TODO

[ppu]
	-- 4. Comparison Operations these will return true(00001) or false(00000):
		-- EQ, NEQ, GT, LT, GTE, LTE can be implemented but might be better suited for flag-based operations.

   -- 5. Other operations specific to GPU can be added later.
		--Clamp: Clamps a value between a minimum and maximum value.
		--Interpolation: Linearly interpolate between two values.
		--Dot Product: Useful in vector math for graphics.
		--Cross Product: Useful for 3D graphics to get a perpendicular vector

[memory_controller]
	 -- Memory Initialization (reset logic)
    PROCESS(inclock)
    BEGIN
        IF rising_edge(inclock) THEN
            IF reset = '1' THEN
                -- Code to initialize memory
                -- This will depend on the internal structure of your RAM component.
                -- For some components, you might need to loop through addresses and write zeros or default values.
            END IF;
        END IF;
    END PROCESS;

		
		
		
################ ORDER OF DOING THINGS

ppu_controller:

    Now that you have a PPU and memory access, you can work on the control logic for the PPU.
	 This will let you initiate operations on the PPU and manage its data flow.

vga_controller:

    Once you have data being processed, you'll want to see the results. 
	 Implement the VGA controller so you can output graphics data to a display.

gpu_top:

    With all the components ready, you can integrate them in the top module. 
	 This will involve connecting all the sub-modules and ensuring data and control signals are appropriately routed.
	 
--------------------------------------
    Vectorized Parallel Operations:
    The ppu_controller can indeed manage vectorized parallel operations. If you're planning on performing operations 
	 on vectors of data, you'll distribute parts of the vectors to different processing units (PPUs) and then collect 
	 and combine the results. This approach ensures that multiple operations can be executed simultaneously, taking 
	 advantage of parallelism.

    Playing Video in Real-time:
    Real-time video playback on an FPGA is a complex task. Here's a simplified overview:
        Your FPGA will need to understand the format of the video data it's receiving.
        You'll need a decoder to decode the video data into individual frames.
        Each frame will then be processed and sent to the VGA controller for display.

    Regarding the Ethernet connection: You'll need an Ethernet IP core or module to handle Ethernet 
	 communication. Once you receive video data via Ethernet, you can buffer it and then process it for display.
	 This task is usually separate from the VGA controller â€“ the VGA controller's primary role is to drive the
	 VGA signals based on the pixel data it receives.

    Given the complexity of video decoding and playback, it would be advisable to handle video as a separate 
	 module or project phase after you've built the basic GPU functionalities.

    Interface with C for Vectorized Math:
    Yes, to interact with your FPGA from a PC or any other platform, you'd typically develop a software 
	 application (in C or another language) that communicates with the FPGA. This application would send 
	 data to the FPGA, instruct it to perform operations, and then retrieve the results.
        This communication can be done over standard interfaces like USB, Ethernet, or even serial, depending
		  on your FPGA board capabilities and the bandwidth you need.
        You'd write a driver or use an existing one for your FPGA to facilitate this communication on the PC side.
        Once the data is sent to the FPGA, your ppu_controller would distribute tasks to the PPU, wait for the 
		  results, and then send them back to the PC.
		  
		  
		  
   +--------------------+      +--------------------+
   |                    |      |                    |
   |    C Program       +----->+    FPGA Driver     |
   |                    |      |                    |
   +--------------------+      +---------+----------+
                                         |
                                         v
   +--------------------+      +---------+----------+
   |                    |      |                    |
   | Ethernet Controller+----->+    PPU Controller  |
   |                    |      |                    |
   +--------------------+      +---------+----------+
                                         |
                                         v
   +--------------------+      +--------------------+
   |                    |      |                    |
   |    VGA Controller  +<---->+     Memory Ctrl    |
   |                    |      |                    |
   +--------------------+      +--------------------+
	POSSIBLE ETHERNET CONNECTIONS
	
	 ENET_DATA to gm_rx_d/gm_tx_d (depending on the configuration).
    ENET_CLK to rx_clk/tx_clk (or separate pins if there are distinct clocks for receive and transmit).
    ENET_RD_N to the read signal.
    ENET_WR_N to the write signal.
    ENET_RST_N to the reset signal.
	
	Here's a mapping of some of these pins to their likely functions within the Ethernet interface:

    ENET_DATA[0] to ENET_DATA[15]: These 16 pins are likely related to the data lines of the Ethernet interface. They might correspond to the GMII/MII data signals (gm_rx_d, gm_tx_d) depending on your configuration (8-bit for MII, 16-bit for GMII).
    ENET_CLK: This could be the Ethernet clock signal, possibly used for both transmit and receive, or there might be separate transmit and receive clocks.
    ENET_CMD: This could be a command signal for the Ethernet interface, although it's unclear without further documentation what specific command(s) it controls.
    ENET_CS_N: Chip select signal, usually used to enable a specific device on a shared bus.
    ENET_INT: This is likely an interrupt signal from the Ethernet PHY to the FPGA, used to signal events like packet reception.
    ENET_RD_N and ENET_WR_N: Read and write control signals, possibly related to the control interface for reading and writing configuration registers.
    ENET_RST_N: Reset signal for the Ethernet interface.

These are general interpretations based on common naming conventions. The exact functions of these pins would be defined in the documentation for the Ethernet PHY on your board or in the reference manual of the board itself.

To make the correct connections in your design, you would need to align these pins with the signals in the generated Ethernet VHDL file. Here's a hypothetical mapping:

    ENET_DATA to gm_rx_d/gm_tx_d (depending on the configuration).
    ENET_CLK to rx_clk/tx_clk (or separate pins if there are distinct clocks for receive and transmit).
    ENET_RD_N to the read signal.
    ENET_WR_N to the write signal.
    ENET_RST_N to the reset signal.

Please note that this mapping is hypothetical and should be verified with the board's documentation and the specific
 configuration of the Ethernet core in your design. Make sure to consult the board's reference manual and 
the documentation of the Ethernet IP core you are using for accurate information.

send and receive data using a UDP connection through the ethernet